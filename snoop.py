from collections import namedtuple

from debug import debug_snoop

BusTxn = namedtuple('BusTxn', ['pn', 'name', 'mem_addr'])

class Snoop():
    def __init__(self, caches):
        self.caches = caches
        self.txns = []
        self.traffic = 0
        self.num_invalidations = 0

    def add_txn(self, txn):
        if txn is not None and txn.name is not None:
            self.txns.append(txn)

    def tick(self):
        self.snoop(self.txns)
        self.txns = []
        for c in self.caches:
            c.tick()

    def snoop(self, bus_txns):
        # if there are no bus txn, return nothing
        if len(bus_txns) == 0:
            return

        # pick 1 to respond to first (for simplicity always choose first)
        print('=== Bus ===')
        print(bus_txns)

        todo = bus_txns[0]

        # only the transaction that is selected gets to commit to new stage
        self.caches[todo.pn].commit()

        # let every other cache to respond to a bus txn
        max_cycles = 0
        pn, bt, ma = todo
        debug_snoop(pn, bt)
        for c in self.caches:
            if c.id == pn:
                continue

            snoop, cycles = c.bus_action(bt, ma, pn)
            # what kinds of  bus action can be generated by a snoop?
            # can only be a flush
            # flush blocks the entire bus for x cycles
            # assume that in this x cycles ma gets into pn's cache too
            if cycles > 0:
                self.num_invalidations += 1
            max_cycles = max(max_cycles, cycles)

        for c in self.caches:
            c.block_for(max(max_cycles, memory_responds(bt)))

        if (max_cycles > 0):
            self.traffic += 1

    def get_summary(self):
        return { 'traffic': self.traffic, 'inval': self.num_invalidations }

def memory_responds(bt):
    return 100
